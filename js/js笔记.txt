1、prototype与[[prototype]]
  a、Function与Boolean、Number一样都是Object的子类
  
  b、var A = function(){};
     相当于生成了一个Function的实例对象
  
  c、prototype是Function特有的一个属性，所以（！！ Function 特有的  ！！）

     {}.prototype                 // undefined  {}类似new Object()
     new Number(1).prototype      // undefined
     new Boolean(true).prototype  // undefined
     
     function g(){}
     g.prototype                  // 不是undefined

     var f = function (){};
         f.prototype              // 不是undefined, 这个对象是js引擎自动生成的

  d、[[prototype]]是每个对象都有  (!! 所有对象都有 ！！)

     当你使用下列语法创建对象时

     function Car(){              // 这是Function的一个实例，它有prototype属性

     }

     var car1 = new Car();       // 当使用 <new 构造函数()>创建对象时
                                 // car1会有一个属性 [[prototype]]
                                 // 这个属性的指向的就是 构造函数的 prototype 所指向的那个对象

     Object.getPrototypeOf(car1) === Car.prototype   // true

     // 属性 [[prototype]] 不能直接访问，必须通过Object.getPrototypeOf(）才能访问
     // 属性 [[prototype]] 所有对象都有
     // 属性 prototype 可以直接访问，且只有Function的对象实例才有
        
        下面有两个函数，名字为A和B，它们都是Function的对象实例，只有它们才有属性prototype，
        而通过它们构建的对象则没有属性prototype，而有属性[[prototype]]

        function A(){}  // 有属性prototype
        new A()         // 没有属性prototype 有属性[[prototype]] 它指向prototype指向的对象

        var B = function (){} //有属性 prototype
        new B()         // 没有属性prototype 有属性[[prototype]] 它指向prototype指向的对象

2、instanceof怎么用
   
   function P(){
	
   }
   var p1 = new P();
   
   console.log(Object.getPrototypeOf(p1) === P.prototype);     // true
   console.log(p1 instanceof P);                               // true

   P.prototype = {}                                            // 令P.prototype指向一个新对象，
                                                               // 而该对象不在p1的prototype chain中
                                                               // 所以 下面两个都为false; 

   console.log(Object.getPrototypeOf(p1) === P.prototype);     // false
   console.log(p1 instanceof P);                               // false

     
     p1 instanceof P, 是看P.prototype所指向的对象是否在p1的prototype chain中, 

     p1的prototype chain如下图所示
    
      p1.[[prototype]] ---> P.prototype ---> Object.prototype ---> null
       

     1) p1由P构造而来，所以p1.[[prototype]] 指向 P.prototype所指向的对象
     
     2) 因为P.prototype所指向的对象是个普通的对象，
        所以p1.[[prototype]].[[prototype]]
        指向的是 Object.prototype所指向的对象

     3) 而Object.prototype所指向的对象的就到头了，
        所以p1.[[prototype]].[[prototype]].[[prototype]]等于null

     
     p1是普通对象，有属性[[prototype]]，没有属性prototype
     
     P是函数对象，有属性prototype (仅函数对象才有该属性，函数对象指的是Function的实例，
                                即咱们定义的函数如function A(){}; var A = function (){})

     p1 是否是 P的实例，就是看P的属性prototype，是否在p1的prototype chain中，算法就是下面的这个函数
     
     function test(instance, Clazz){
       var temp = Object.getPrototypeOf(instance);
       while(temp && temp != Clazz.prototype){
          temp = Object.getPrototypeOf(temp);
      }
       return !!temp;
     }

     test(p1, P);
     

    参考链接
    https://javascriptrefined.io/function-and-object-instances-of-each-other-1e1095d5faac
    https://stackoverflow.com/questions/24453301/how-does-instanceof-work-in-javascript


3、setTimeout和setInterval的原理
   a、语法
      setTimeout(code|fun, delay, [arg1, arg2,....,argn])  
      setInterval(code|fun, delay, [arg1, arg2,....,argn])  
      
      "code|fun"                是要执行的代码或函数
      "delay"                   指定推后多少秒执行
      "[arg1, arg2,....,argn]"  这些参数会传给前面的函数

  b、原理
     1) 将 “code|fun”变为下面对象，塞进队列中
        var task = {
         "work": code| func,
         "executeTime":当前时间+delay //当前时间就是调用setTimeout or setInterval的时间点
        }
        queue.push(task);
     2) 在下次事件循环中，轮询队列，执行到达执行时间的函数
        var now = Date.now();
        queue.forEach(function(task){
          if(now - task.executeTime >= 0){
              task.work();
          }
        });

4、实现类似java中的sleep函数
   function sleep(ms){
     var start = Date.now();
     while(Date.now()- start < ms);
   }

5、变量结构赋值
   
   基本语法: http://es6.ruanyifeng.com/#docs/destructuring

   var rs = [[1,2], [3,4]].map(([x, y]) => x + y);
   
   等价于:
   
   1) js伪代码
   function myMap([x, y]){  //这个表明函数接收数组为参数
     return x + y;
   }

   [[1,2], [3,4]].map(myMap);

   2) java伪代码
   List<List> source = new ArrayList();
   List des = new ArrayList();
   for(List e : source){
      Object newVal = map(e);
      des.add(newVal);
   }

   void int map(List arr){
     int x = arr.get(0);
     int y = arr.get(1);
     return x + y;
   }

6、Object.keys(), Object.getOwnPropertyNames(), for in
   1) Object.keys()                  // 只遍历 <自身> 的属性，且属性必须是 <可枚举> 的
      Object.getOwnPropertyNames()   // 只遍历 <自身> 的属性, 包括 <可枚举> 和 <不可枚举>

      例子
      let o = {};
      Object.defineProperty(o, "noEnumerable", {
          value: 1,
          enumerable: false
      })

      Object.defineProperty(o, 'enumerable', {
         value: 2,
         enumerable: true
      })

      let keys_1 = Object.keys(o);
      let keys_2 = Object.getOwnPropertyNames(o);

      console.log(`Object.keys = ${keys_1}`);                 // Object.keys = enumerable

      console.log(`Object.getOwnPropertyNames = ${keys_2}`);  // Object.getOwnPropertyNames = noEnumerable,enumerable
  
  2) for in 可以遍历 <自身> 和其 <父类> 的 <可枚举> 属性
     function Parent(){
     }
     Parent.prototype.tostring = function(){
         console.log("tostring");
     }
     let o = new Parent();
     o.enumerable = 1;
     for(let key in o){
         console.log(key)            //  enumerable, tostring
     }
      
 7、全局变量
   1) 浏览器脚本
      var a = 1;
      console.log(`window.a = ${window.a}`); // window.a = 1
   2) node 
      REPL(命令行下,直接敲node进入)
        var a = 1;
        console.log(`global.a = ${global.a}`); // global.a = 1
	
   **** 脚本中(node index.js) *******
        var a = 1;
        console.log(`global.a = ${global.a}`); // global.a = undefined
   这是因为node在执行脚本时,会把脚本包在一个方法中, 所以脚本中的全局变量并不是绑定到global上去的
   
   参考链接: https://stackoverflow.com/questions/34967530/about-global-variables-in-node-js
 
 8、this和arrow function
   let o = {
       name: 'z3',
       p: () => console.log(this)
   }
   o.p();  // node命令行和浏览器中运行结果为 global和 window, node脚本中运行时为空对象{}
   这是因为 arrow function 的this 是继承parent scope的this,
   node命令行的this       global                  // 直接在命令行敲node进入命令行模式
   浏览器中的this         window            
   node脚本中的this       {}                      //  node index.js
   
   参考链接 https://www.codementor.io/@dariogarciamoya/understanding-this-in-javascript-with-arrow-functions-gcpjwfyuc
   
   9、let|const 和 var在声明全局变量时的区别
     let|const声明的全局变量不会绑定到window或global上, 而var会
     所以
     let name = 'zs' 
     // var name = 'z3'
     function a(){
        console.log(this.name); 
     }
     
     a() // 能看到var定义的name而看不到let定义的name, 注意this指向的window或global
     
     参考链接: https://stackoverflow.com/questions/28776079/do-let-statements-create-properties-on-the-global-object
  
  10、document.readyState的值与事件DOMContentLoaded, 事件load的关系
      1) document.readyState 只能取下面三种值
         loading
	 interactive    ---> 当 DOMContentLoaded 事件触发时
	 complete       ---> 当 load 事件触发时
	 
	 loading（网页正在加载）、interactive（网页已经解析完成，但是外部资源仍然处在加载状态）和complete（网页和所有外部资源已经结束加载，load事件即将触发
	 参考链接: https://wangdoc.com/javascript/events/common.html#%E7%BD%91%E9%A1%B5%E7%8A%B6%E6%80%81%E4%BA%8B%E4%BB%B6
      2) 几个例子
         <html>
            <head>
	      <script>
	         console.log(`${document.readyState}`);          // loading
		 console.log(`${document.getElementById('p1')}`) // null
              </script>
	    </head>
	    <body>
	       <p id='p1'>script放在head里的情况</p>
	    </body>
	 </html>
	 
	 
	  <html>
            <head>
	    </head>
	    <body>
	       <p id='p1'>script放在 *中间* 的情况</p>
	       <script>
	         console.log(`${document.readyState}`);          // loading
		 console.log(`${document.getElementById('p1')}`) // p1
		 console.log(`${document.getElementById('p2')}`) // null
               </script>
	        <p id='p2'>我在script后面</p>
	    </body>
	 </html>
         
	 
	<html>
            <head>
	    </head>
	    <body>
	       <p id='p1'>script放在 *中间* 的情况</p>
	       <script>
	         console.log(`${document.readyState}`);              // loading
		 window.addEventListener('DOMContentLoaded', () => {
		     console.log(`${document.readyState}`);          // interactive
		 });
		 window.addEventListener('load', () => {
		     console.log(`${document.readyState}`);          // complete
		 });
               </script>
	    </body>
	 </html>
	 
      3) window.addEventListener 和 docuement.addEventListener的区别
         window.addEventListener    把事件监听函数绑定到window上, 而
	 docuement.addEventListener 把事件监听函数绑定到docuement上.
	 当绑定的事件可以冒泡传播时,
	 会先调用docuement上面的监听函数, 然后
	 调用window上面的监听函数, 比如 DOMContentLoaded事件
