1、prototype与[[prototype]]
  a、Function与Boolean、Number一样都是Object的子类
  
  b、var A = function(){};
     相当于生成了一个Function的实例对象
  
  c、prototype是Function特有的一个属性，所以（！！ Function 特有的  ！！）

     {}.prototype                 // undefined  {}类似new Object()
     new Number(1).prototype      // undefined
     new Boolean(true).prototype  // undefined
     
     function g(){}
     g.prototype                  // 不是undefined

     var f = function (){};
         f.prototype              // 不是undefined, 这个对象是js引擎自动生成的

  d、[[prototype]]是每个对象都有  (!! 所有对象都有 ！！)

     当你使用下列语法创建对象时

     function Car(){              // 这是Function的一个实例，它有prototype属性

     }

     var car1 = new Car();       // 当使用 <new 构造函数()>创建对象时
                                 // car1会有一个属性 [[prototype]]
                                 // 这个属性的指向的就是 构造函数的 prototype 所指向的那个对象

     Object.getPrototypeOf(car1) === Car.prototype   // true

     // 属性 [[prototype]] 不能直接访问，必须通过Object.getPrototypeOf(）才能访问
     // 属性 [[prototype]] 所有对象都有
     // 属性 prototype 可以直接访问，且只有Function的对象实例才有
        
        下面有两个函数，名字为A和B，它们都是Function的对象实例，只有它们才有属性prototype，
        而通过它们构建的对象则没有属性prototype，而有属性[[prototype]]

        function A(){}  // 有属性prototype
        new A()         // 没有属性prototype 有属性[[prototype]] 它指向prototype指向的对象

        var B = function (){} //有属性 prototype
        new B()         // 没有属性prototype 有属性[[prototype]] 它指向prototype指向的对象

2、instanceof怎么用
   
   function P(){
	
   }
   var p1 = new P();
   
   console.log(Object.getPrototypeOf(p1) === P.prototype);     // true
   console.log(p1 instanceof P);                               // true

   P.prototype = {}                                            // 令P.prototype指向一个新对象，
                                                               // 而该对象不在p1的prototype chain中
                                                               // 所以 下面两个都为false; 

   console.log(Object.getPrototypeOf(p1) === P.prototype);     // false
   console.log(p1 instanceof P);                               // false

     
     p1 instanceof P, 是看P.prototype所指向的对象是否在p1的prototype chain中, 

     p1的prototype chain如下图所示
    
      p1.[[prototype]] ---> P.prototype ---> Object.prototype ---> null
       

     1) p1由P构造而来，所以p1.[[prototype]] 指向 P.prototype所指向的对象
     
     2) 因为P.prototype所指向的对象是个普通的对象，
        所以p1.[[prototype]].[[prototype]]
        指向的是 Object.prototype所指向的对象

     3) 而Object.prototype所指向的对象的就到头了，
        所以p1.[[prototype]].[[prototype]].[[prototype]]等于null

     
     p1是普通对象，有属性[[prototype]]，没有属性prototype
     
     P是函数对象，有属性prototype (仅函数对象才有该属性，函数对象指的是Function的实例，
                                即咱们定义的函数如function A(){}; var A = function (){})

     p1 是否是 P的实例，就是看P的属性prototype，是否在p1的prototype chain中，算法就是下面的这个函数
     
     function test(instance, Clazz){
       var temp = Object.getPrototypeOf(instance);
       while(temp && temp != Clazz.prototype){
          temp = Object.getPrototypeOf(temp);
      }
       return !!temp;
     }

     test(p1, P);
     

    参考链接
    https://javascriptrefined.io/function-and-object-instances-of-each-other-1e1095d5faac
    https://stackoverflow.com/questions/24453301/how-does-instanceof-work-in-javascript


3、setTimeout和setInterval的原理
   a、语法
      setTimeout(code|fun, delay, [arg1, arg2,....,argn])  
      setInterval(code|fun, delay, [arg1, arg2,....,argn])  
      
      "code|fun"                是要执行的代码或函数
      "delay"                   指定推后多少秒执行
      "[arg1, arg2,....,argn]"  这些参数会传给前面的函数

  b、原理
     1) 将 “code|fun”变为下面对象，塞进队列中
        var task = {
         "work": code| func,
         "executeTime":当前时间+delay //当前时间就是调用setTimeout or setInterval的时间点
        }
        queue.push(task);
     2) 在下次事件循环中，轮询队列，执行到达执行时间的函数
        var now = Date.now();
        queue.forEach(function(task){
          if(now - task.executeTime >= 0){
              task.work();
          }
        });

4、实现类似java中的sleep函数
   function sleep(ms){
     var start = Date.now();
     while(Date.now()- start < ms);
   }

5、变量结构赋值
   
   基本语法: http://es6.ruanyifeng.com/#docs/destructuring

   var rs = [[1,2], [3,4]].map(([x, y]) => x + y);
   
   等价于:
   
   1) js伪代码
   function myMap([x, y]){  //这个表明函数接收数组为参数
     return x + y;
   }

   [[1,2], [3,4]].map(myMap);

   2) java伪代码
   List<List> source = new ArrayList();
   List des = new ArrayList();
   for(List e : source){
      Object newVal = map(e);
      des.add(newVal);
   }

   void int map(List arr){
     int x = arr.get(0);
     int y = arr.get(1);
     return x + y;
   }

6、Object.keys(), Object.getOwnPropertyNames(), Object.getOwnPropertySymbols(), for in 
   1) Object.keys()                  // 只遍历 <自身> 的属性，且属性必须是 <可枚举> 的
      Object.getOwnPropertyNames()   // 只遍历 <自身> 的属性, 包括 <可枚举> 和 <不可枚举>
      Object.getOwnPropertySymbols() // 返回对象的通过Symbol定义的属性

      例子
      let o = {};
      Object.defineProperty(o, "noEnumerable", {
          value: 1,
          enumerable: false
      });

      Object.defineProperty(o, 'enumerable', {
         value: 2,
         enumerable: true
      });

      // 属性名              值
      o[Symbol.iterator] = 'Symbol';

      let keys_1 = Object.keys(o);
      let keys_2 = Object.getOwnPropertyNames(o);
      let keys_3 = Object.getOwnPropertySymbols(o);

      console.log(`Object.keys = ${keys_1}`);                   // Object.keys = enumerable

      console.log(`Object.getOwnPropertyNames = ${keys_2}`);    // Object.getOwnPropertyNames = noEnumerable,enumerable

      console.log(`Object.getOwnPropertySymbols = ${keys_3}`);  // Object.getOwnPropertySymbols = Symbol(Symbol.iterator)
  
  2) for in 可以遍历 <自身> 和其 <父类> 的 <可枚举> 属性
     function Parent(){
     }
     Parent.prototype.tostring = function(){
         console.log("tostring");
     }
     let o = new Parent();
     o.enumerable = 1;
     for(let key in o){
         console.log(key)            //  enumerable, tostring
     }
      
 7、全局变量
   1) 浏览器脚本
      var a = 1;
      console.log(`window.a = ${window.a}`); // window.a = 1
   2) node 
      REPL(命令行下,直接敲node进入)
        var a = 1;
        console.log(`global.a = ${global.a}`); // global.a = 1
	
   **** 脚本中(node index.js) *******
        var a = 1;
        console.log(`global.a = ${global.a}`); // global.a = undefined
   这是因为node在执行脚本时,会把脚本包在一个方法中, 所以脚本中的全局变量并不是绑定到global上去的
   
   参考链接: https://stackoverflow.com/questions/34967530/about-global-variables-in-node-js
 
 8、this和arrow function
   let o = {
       name: 'z3',
       p: () => console.log(this)
   }
   o.p();  // node命令行和浏览器中运行结果为 global和 window, node脚本中运行时为空对象{}
   这是因为 arrow function 的this 是继承parent scope的this,
   node命令行的this       global                  // 直接在命令行敲node进入命令行模式
   浏览器中的this         window            
   node脚本中的this       {}                      //  node index.js
   
   参考链接 https://www.codementor.io/@dariogarciamoya/understanding-this-in-javascript-with-arrow-functions-gcpjwfyuc
   
   9、let|const 和 var在声明全局变量时的区别
     let|const声明的全局变量不会绑定到window或global上, 而var会
     所以
     let name = 'zs' 
     // var name = 'z3'
     function a(){
        console.log(this.name); 
     }
     
     a() // 能看到var定义的name而看不到let定义的name, 注意this指向的window或global
     
     参考链接: https://stackoverflow.com/questions/28776079/do-let-statements-create-properties-on-the-global-object
  
  10、document.readyState的值与事件DOMContentLoaded, 事件load的关系
      1) document.readyState 只能取下面三种值
         loading
	 interactive    ---> 当 DOMContentLoaded 事件触发时
	 complete       ---> 当 load 事件触发时
	 
	 loading
	   当前页面的标签还没有解析完
	 
	 interactive
	   当前页面的DOM树已经生成完, 可以使用docuement.getElementById获取DOM元素
	   但是iframe的页面, srcipt引用的外部脚本, 以及引用的外部css还没有加载完成
	 
	 complete 
	    网页和所有外部资源已经结束加载，load事件即将触发
	 参考链接: https://wangdoc.com/javascript/events/common.html#%E7%BD%91%E9%A1%B5%E7%8A%B6%E6%80%81%E4%BA%8B%E4%BB%B6
	          https://wangdoc.com/javascript/dom/document.html 搜document.readyState
      2) 几个例子
         <html>
            <head>
	      <script>
	         console.log(`${document.readyState}`);          // loading
		 console.log(`${document.getElementById('p1')}`) // null
              </script>
	    </head>
	    <body>
	       <p id='p1'>script放在head里的情况</p>
	    </body>
	 </html>
	 
	 
	  <html>
            <head>
	    </head>
	    <body>
	       <p id='p1'>script放在 *中间* 的情况</p>
	       <script>
	         console.log(`${document.readyState}`);          // loading
		 console.log(`${document.getElementById('p1')}`) // p1
		 console.log(`${document.getElementById('p2')}`) // null
               </script>
	        <p id='p2'>我在script后面</p>
	    </body>
	 </html>
         
	 
	<html>
            <head>
	    </head>
	    <body>
	       <p id='p1'>script放在 *中间* 的情况</p>
	       <script>
	         console.log(`${document.readyState}`);              // loading
		 window.addEventListener('DOMContentLoaded', () => {
		     console.log(`${document.readyState}`);          // interactive
		 });
		 window.addEventListener('load', () => {
		     console.log(`${document.readyState}`);          // complete
		 });
               </script>
	    </body>
	 </html>
	 
      3) window.addEventListener 和 docuement.addEventListener的区别
         window.addEventListener    把事件监听函数绑定到window上, 而
	 docuement.addEventListener 把事件监听函数绑定到docuement上.
	 当绑定的事件可以冒泡传播时,
	 会先调用docuement上面的监听函数, 然后
	 调用window上面的监听函数, 比如 DOMContentLoaded事件


11. js的正则表达式

  1) js的正则表达式 是部分匹配的

     /a/.test('a')  // true
     
     /a/.test('ba')  // true

     /a/.test('aca')  // true

     下面就是一个容易犯的错, 用正则表达式抓取
      协议 主机 端口

      /https?:\/\/[^/:]+(:\d{2,4})?/   这是一个错误的正则,因为

      http://a: 也会返回true, 因为正则表达式部分匹配了http://a

      要想达到完全匹配应该用, ^$来规定边界

      /^https?:\/\/[^:/](:\d{2,4})?$/


12. typeof vs Object.prototype.toString()
      js共有7种类型: number, boolean, string, null, undefined, object, symbol
    12.1) typeof判断数据类型
          
          typeof 1                -->  number
          typeof new Number(1)    -->  object
          

          typeof null             -->  object
          typeof undefined        -->  undefined
          
          function a(){}
          typeof a                --> function

          typeof []               --> object 
    
    12.2) typeof 最佳实践
          function a(v){
            // let b = v || '默认值'; 当v赋值为false时，这里就会错误的给b赋予 '默认值'
            let b  = v;
            if(typeof b == 'undefined' || b === null){
               b = '默认值'
            }
          }

    12.3) Object.prototype.toString.call(v)判断数据类型 
           [object Number] Number是构造函数的名字            
           
            v                    type
            1                    [object Number]
            undefined            [object Undefined]
            null                 [object Null]

13. 自动转换为false的类型
    null, undefined, '', 0, false

14. 箭头函数的返回值
     let a = val => val * 5;   // 这样写 隐含函数a的返回是 val * 5
     let a = val => { val *5 } // 这样写 返回undefined, 必须显示的加上return

15. CORS 请求详解
    1. 简单请求
       浏览器： 增加一个请求头origin,                             origin: http://192.30.0.231:8081
       服务器: 增加一个响应头Access-Control-Allow-Origin,         Access-Control-Allow-Origin: http://192.30.0.231:8081(or *)

    2. 非简单请求
        浏览器发两次请求:
           preflight request: 1 请求方法必须为OPTIONS, 新增请求头origin, Access-Control-Request-Method
           后续请求:  新增请求头 origin
        服务器: 对preflight request的响应, 新增响应头Access-Control-Allow-Origin, Access-Control-Request-Method
    3. 例子
        1)浏览器发起的preflight request
           OPTIONS /user/view/1 HTTP/1.1
           Origin: http://192.30.0.231:8081
           Access-Control-Request-Method: PUT

        2) 服务器对preflight request的响应
           HTTP/1.1 200 OK
           Access-Control-Allow-Origin: http://192.30.0.231:8081(or *)
           Access-Control-Allow-Methods: GET, POST, PUT (必须包含Access-Control-Request-Method的值)
    4. 注意 origin 字段是有 协议 + 域名 + 端口
       origin: http://192.30.0.231:8018    合法
       origin: 192.30.0.231:8018           不正确

16. ArrayBuffer

  1)简介
    ArrayBuffer只负责分配内存.
    UintXArray, IntXArray以X大小的字节读写ArrayBuffer分配的内存(X代表8, 16, 32).
    DataView用getIntX(setIntX), getUintX(setIntX)以X大小的字节读写ArrayBuffer分配的内存.

    Uint8Array                             无符号1字节整数
    Uint16Array                            无符号2字节整数
    Int8Array                              有符号1字节整数

    // 分配1字节的内存
    const buff = new ArrayBuffer(1);

    // 读写内存
    const a1 = new Uint8Array(buff);
    console.log(a1[0]);        // 读内存
    a1[0] = 1;                 // 写内存, js默认使用小端方式(little-endina)进行写内存, 见下面附录2

  2)例子
    const buffer = new ArrayBuffer(2);      //申请2字节内存
    const b1 = new Uint8Array(buffer);      //Uint8Array, 每次可以1个字节的大小读写上面的内存
    b1[0] = 1;                              // 在上面2字节内存中的 高位 地址写入1    0000 0000 0000 0001  0x0001
    b1[1] = 2;                              // 在上面2字节内存中的 低位 地址写入2    0000 0010 0000 0001  0x0201
    const b2 = new Uint16Array(buffer);     //Uint16Array, 每次可以2个字节的大小读写上面的内存
    console.log(b2[0]);                     // 一次读取2个字节, 0x0201

17. XMLHttpRequest
    1) 使用
       const xhr = new XMLHttpRequest();
       xhr.open('GET', 'http://192.30.0.231:8080/test');
       const body;
       xhr.onreadystatechange = callback     // 当xhr.readyState发生变化时, 回调函数会被调用
       xhr.send(body);                       // body的内容将放在请求体中

    2) XMLHttpRequest.send(body)的注意事项
       2.1) body 可以是Document,
                      Blob, BufferSource, FormData, URLSearchParams, USVString.
                      null
       2.2)当使用GET或HEAD时, send(body) 等价于 send(null)

       2.3) 不同类型的body的content-type
            body                       content-type                        playload
            FormData                   multipart/form-data                 按照multipart/form-data进行编码
            URLSearchParams            application/x-www-form-urlencoded   按照application/x-www-form-urlencoded进行编码

18. XMLHttRequest.abort()的原理及应用场景
    1) 原理
       重置XMLHttpRequest的 readyState 和 status为0           // 这句参考 https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/abort
       并且不会触发 xhr.onreadystatechange设置的回调函数的执行   // 这句参考 https://xhr.spec.whatwg.org/#the-abort()-method
    2) open, send, abort实现的猜测
       2.1) XMLHttpRequest.readyState的取值及意义
           0          表示 XMLHttpRequest 实例已经生成, 但是实例的open()方法还没有被调用
           1          表示open()方法已经调用, 但是实例的send()方法还没有调用
           2          send()方法已经调用, *** 并且服务器返回的头信息和状态码已经收到 ***
           3          表示正在接收服务器传来的数据体
           4          表示服务器返回的数据已经完全接收, *** 或者本次接收已经失败 ***
           注意2和4星号括起来的部分
       2.2) 例子
            var xhr = new XMLHttpRequest();                              // readyState = 0
                xhr.onreadystatechange = callback
                xhr.open('GET', 'http://192.30.0.231:8080/test');       // readyState由 0 => 1, callback会被调用
                xhr.send();                                             // send方法返回后, readyState的值不会变化, 进而callback也不会调用
                xhr.abort();                                            // readyState由 1 => 0, 根据规范不会触发callback, 且将status设为0
           为什么send方法返回后不会改变readyState, 这是因为:
            1)readyState由 0 => 1, 不仅需要send方法被调用且收到服务器返回的头信息(见2.1的星号部分)
            2)所以send方法, 应该把发送http请求, 改变readyState, 调用callback, 封装到一个定时任务中
            3)上面两点可以这么验证, 因为js是单线程所以在xhr.abort()上面打断点, 会导致send方法放置的定时任务无法执行
              如果send方法直接修改readyState, 则当程序停到断点处时, readyState由 1 => 2, 进而callback被调用
              反之则证明send方法没有直接修改readyState
            4) 文档 https://xhr.spec.whatwg.org/#the-abort()-method 详细介绍了 open, send, abort的具体步骤
        2.3) 详解
        1. constructor()
           1.1) this.state = UNSET(0)             // 即XMLHttpRequest.readyState, 它是一个getter函数

        2. open()
           2.1) this.sendFlag = false
           2.2) this.synchronousFlag = false
           2.3) this.response = Response.Error;
           2.4) this.state = OPENED(1)            // 即XMLHttpRequest.readyState, 它是一个getter函数
           2.5) 触发readystatechange

        3. send()
           3.1) this.sendFlag = true
           3.2) if(this.state != OPENED || !this.sendFlag)时,不执行下面的步骤
           3.3) 放置定时任务(To process response)

        4. send()放置的定时任务
           4.1) if(this.response == Response.Error)时,不执行下面的步骤
           4.2) this.state = HEADERS_RECEIVED(2)
           4.3) 触发readystatechange               // 注意callback可以改变this.state,所以才做下面的检查
           4.4) if(this.state != HEADERS_RECEIVED)时,不执行下面的步骤
           4.5) if(this.response == Response.Error)时,不执行下面的步骤
           4.6) this.state = DONE(2)
           4.7) this.sendFlag = false
           4.8) 触发readystatechange
    3) 应用场景
       当用户连续触发两次请求req1, req2, 且req2的响应快于req1时
       req2的响应可能被延迟的req1的响应所覆盖(复现请看附录3)
       此时就应该在发送第二次请req2求前执行req1.abort()

    参考文档: https://stackoverflow.com/questions/39157737/what-happens-when-an-xmlhttprequest-is-aborted

19. postMessage的用法
    1) 父向子发
       subWin.postMessage(data, origin);          //  subWin: 子窗口
                                                  //  origin: 子窗口的源(协议+主机名+端口)
    2) 子向父发
       parentWin.postMessage(data, origin);       //  parentWin: 父窗口
                                                  //  origin:    父窗口的源(协议+主机名+端口)
    3) 在父窗口监听子窗口的message事件
      window.addEventListener('message', e => {
         e.source                                // 子窗口即window对象
         e.origin                                // 子窗口发送消息时填的origin, 一般为*(或父窗口的地址)否则浏览器就会报错
                                                 // 即, parentWin.postMessage(data, origin); e.origin就是这里填的origin
      });


附录1 用google搜索指定网站
      关键词 site:https://wangdoc.com/
附录2 大端和小端的区别
      写入数据  0x1122 (16进制)
      大端                          小端
          地址  0        1               0          1
          数据  0x11     0x22            0x22       0x11
      小端先写高地址,再写低地址
附录3
        <p id="content">还未请求</p>
        <button id="btn1">发送请求1</button>
        <br>
        <button id="btn2">发送请求2</button>
        <br>
        <script>
            const btn1 = document.getElementById('btn1');
            const btn2 = document.getElementById('btn2');
            const content = document.getElementById('content');
            const server = 'http://192.30.0.231:8080';
            let xhr = null;
            let i = 1;
            btn1.addEventListener('click', () => {
                sendRequest(server + '/xh1', updateContent);
            });

            btn2.addEventListener('click', () => {
                sendRequest(server + '/xh2', updateContent);
            });
            function sendRequest(api, callback, method) {
                if(xhr){
                    //xhr.abort() 放开注释就可以解决问题
                }
                let methodToUse = method || 'GET';
                xhr = new XMLHttpRequest();
                xhr.open(methodToUse, api);
                xhr.onreadystatechange = createCallback(xhr, callback);
                xhr.send();
            }
            function createCallback(xhr, callback) {
                return () => {
                    if (xhr.readyState == 4 && xhr.status == 200) {
                        const data = xhr.responseText;
                        callback(data);
                    }
                }
            }
            function updateContent(data) {
                content.innerText = data;
            }
        </script>