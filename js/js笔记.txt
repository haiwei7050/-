1、prototype与[[prototype]]
  a、Function与Boolean、Number一样都是Object的子类
  
  b、var A = function(){};
     相当于生成了一个Function的实例对象
  
  c、prototype是Function特有的一个属性，所以（！！ Function 特有的  ！！）

     {}.prototype                 // undefined  {}类似new Object()
     new Number(1).prototype      // undefined
     new Boolean(true).prototype  // undefined
     
     function g(){}
     g.prototype                  // 不是undefined

     var f = function (){};
         f.prototype              // 不是undefined, 这个对象是js引擎自动生成的

  d、[[prototype]]是每个对象都有  (!! 所有对象都有 ！！)

     当你使用下列语法创建对象时

     function Car(){              // 这是Function的一个实例，它有prototype属性

     }

     var car1 = new Car();       // 当使用 <new 构造函数()>创建对象时
                                 // car1会有一个属性 [[prototype]]
                                 // 这个属性的指向的就是 构造函数的 prototype 所指向的那个对象

     Object.getPrototypeOf(car1) === Car.prototype   // true

     // 属性 [[prototype]] 不能直接访问，必须通过Object.getPrototypeOf(）才能访问
     // 属性 [[prototype]] 所有对象都有
     // 属性 prototype 可以直接访问，且只有Function的对象实例才有
        
        下面有两个函数，名字为A和B，它们都是Function的对象实例，只有它们才有属性prototype，
        而通过它们构建的对象则没有属性prototype，而有属性[[prototype]]

        function A(){}  // 有属性prototype
        new A()         // 没有属性prototype 有属性[[prototype]] 它指向prototype指向的对象

        var B = function (){} //有属性 prototype
        new B()         // 没有属性prototype 有属性[[prototype]] 它指向prototype指向的对象

2、instanceof怎么用
   
   function P(){
	
   }
   var p1 = new P();
   
   console.log(Object.getPrototypeOf(p1) === P.prototype);     // true
   console.log(p1 instanceof P);                               // true

   P.prototype = {}                                            // 令P.prototype指向一个新对象，
                                                               // 而该对象不在p1的prototype chain中
                                                               // 所以 下面两个都为false; 

   console.log(Object.getPrototypeOf(p1) === P.prototype);     // false
   console.log(p1 instanceof P);                               // false

     
     p1 instanceof P, 是看P.prototype所指向的对象是否在p1的prototype chain中, 

     p1的prototype chain如下图所示
    
      p1.[[prototype]] ---> P.prototype ---> Object.prototype ---> null
       

     1) p1由P构造而来，所以p1.[[prototype]] 指向 P.prototype所指向的对象
     
     2) 因为P.prototype所指向的对象是个普通的对象，
        所以p1.[[prototype]].[[prototype]]
        指向的是 Object.prototype所指向的对象

     3) 而Object.prototype所指向的对象的就到头了，
        所以p1.[[prototype]].[[prototype]].[[prototype]]等于null

     
     p1是普通对象，有属性[[prototype]]，没有属性prototype
     
     P是函数对象，有属性prototype (仅函数对象才有该属性，函数对象指的是Function的实例，
                                即咱们定义的函数如function A(){}; var A = function (){})

     p1 是否是 P的实例，就是看P的属性prototype，是否在p1的prototype chain中，算法就是下面的这个函数
     
     function test(instance, Clazz){
       var temp = Object.getPrototypeOf(instance);
       while(temp && temp != Clazz.prototype){
          temp = Object.getPrototypeOf(temp);
      }
       return !!temp;
     }

     test(p1, P);
     

    参考链接
    https://javascriptrefined.io/function-and-object-instances-of-each-other-1e1095d5faac
    https://stackoverflow.com/questions/24453301/how-does-instanceof-work-in-javascript


3、setTimeout和setInterval的原理
   a、语法
      setTimeout(code|fun, delay, [arg1, arg2,....,argn])  
      setInterval(code|fun, delay, [arg1, arg2,....,argn])  
      
      "code|fun"                是要执行的代码或函数
      "delay"                   指定推后多少秒执行
      "[arg1, arg2,....,argn]"  这些参数会传给前面的函数

  b、原理
     1) 将 “code|fun”变为下面对象，塞进队列中
        var task = {
         "work": code| func,
         "executeTime":当前时间+delay //当前时间就是调用setTimeout or setInterval的时间点
        }
        queue.push(task);
     2) 在下次事件循环中，轮询队列，执行到达执行时间的函数
        var now = Date.now();
        queue.forEach(function(task){
          if(now - task.executeTime >= 0){
              task.work();
          }
        });

4、实现类似java中的sleep函数
   function sleep(ms){
     var start = Date.now();
     while(Date.now()- start < ms);
   }

5、变量结构赋值
   
   基本语法: http://es6.ruanyifeng.com/#docs/destructuring

   var rs = [[1,2], [3,4]].map(([x, y]) => x + y);
   
   等价于:
   
   1) js伪代码
   function myMap([x, y]){  //这个表明函数接收数组为参数
     return x + y;
   }

   [[1,2], [3,4]].map(myMap);

   2) java伪代码
   List<List> source = new ArrayList();
   List des = new ArrayList();
   for(List e : source){
      Object newVal = map(e);
      des.add(newVal);
   }

   void int map(List arr){
     int x = arr.get(0);
     int y = arr.get(1);
     return x + y;
   }


