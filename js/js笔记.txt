1、prototype与[[prototype]]
  a、Function与Boolean、Number一样都是Object的子类
  
  b、var A = function(){};
     相当于生成了一个Function的实例对象
  
  c、prototype是Function特有的一个属性，所以（！！ Function 特有的  ！！）

     {}.prototype                 // undefined  {}类似new Object()
     new Number(1).prototype      // undefined
     new Boolean(true).prototype  // undefined
     
     function g(){}
     g.prototype                  // 不是undefined

     var f = function (){};
         f.prototype              // 不是undefined, 这个对象是js引擎自动生成的

  d、[[prototype]]是每个对象都有  (!! 所有对象都有 ！！)

     当你使用下列语法创建对象时

     function Car(){              // 这是Function的一个实例，它有prototype属性

     }

     var car1 = new Car();       // 当使用 <new 构造函数()>创建对象时
                                 // car1会有一个属性 [[prototype]]
                                 // 这个属性的指向的就是 构造函数的 prototype 所指向的那个对象

     Object.getPrototypeOf(car1) === Car.prototype   // true

     // 属性 [[prototype]] 不能直接访问，必须通过Object.getPrototypeOf(）才能访问
     // 属性 [[prototype]] 所有对象都有
     // 属性 prototype 可以直接访问，且只有Function的对象实例才有
        
        下面有两个函数，名字为A和B，它们都是Function的对象实例，只有它们才有属性prototype，
        而通过它们构建的对象则没有属性prototype，而有属性[[prototype]]

        function A(){}  // 有属性prototype
        new A()         // 没有属性prototype 有属性[[prototype]] 它指向prototype指向的对象

        var B = function (){} //有属性 prototype
        new B()         // 没有属性prototype 有属性[[prototype]] 它指向prototype指向的对象

2、instanceof怎么用
   
   function P(){
	
   }
   var p1 = new P();
   
   console.log(Object.getPrototypeOf(p1) === P.prototype);     // true
   console.log(p1 instanceof P);                               // true

   P.prototype = {}                                            // 令P.prototype指向一个新对象，
                                                               // 而该对象不在p1的prototype chain中
                                                               // 所以 下面两个都为false; 

   console.log(Object.getPrototypeOf(p1) === P.prototype);     // false
   console.log(p1 instanceof P);                               // false

     
     p1 instanceof P, 是看P.prototype所指向的对象是否在p1的prototype chain中, 

     p1的prototype chain如下图所示
    
      p1.[[prototype]] ---> P.prototype ---> Object.prototype ---> null
       

     1) p1由P构造而来，所以p1.[[prototype]] 指向 P.prototype所指向的对象
     
     2) 因为P.prototype所指向的对象是个普通的对象，
        所以p1.[[prototype]].[[prototype]]
        指向的是 Object.prototype所指向的对象

     3) 而Object.prototype所指向的对象的就到头了，
        所以p1.[[prototype]].[[prototype]].[[prototype]]等于null

     
     p1是普通对象，有属性[[prototype]]，没有属性prototype
     
     P是函数对象，有属性prototype (仅函数对象才有该属性，函数对象指的是Function的实例，
                                即咱们定义的函数如function A(){}; var A = function (){})

     p1 是否是 P的实例，就是看P的属性prototype，是否在p1的prototype chain中，算法就是下面的这个函数
     
     function test(instance, Clazz){
       var temp = Object.getPrototypeOf(instance);
       while(temp && temp != Clazz.prototype){
          temp = Object.getPrototypeOf(temp);
      }
       return !!temp;
     }

     test(p1, P);
     

    参考链接
    https://javascriptrefined.io/function-and-object-instances-of-each-other-1e1095d5faac
    https://stackoverflow.com/questions/24453301/how-does-instanceof-work-in-javascript


3、setTimeout和setInterval的原理
   a、语法
      setTimeout(code|fun, delay, [arg1, arg2,....,argn])  
      setInterval(code|fun, delay, [arg1, arg2,....,argn])  
      
      "code|fun"                是要执行的代码或函数
      "delay"                   指定推后多少秒执行
      "[arg1, arg2,....,argn]"  这些参数会传给前面的函数

  b、原理
     1) 将 “code|fun”变为下面对象，塞进队列中
        var task = {
         "work": code| func,
         "executeTime":当前时间+delay //当前时间就是调用setTimeout or setInterval的时间点
        }
        queue.push(task);
     2) 在下次事件循环中，轮询队列，执行到达执行时间的函数
        var now = Date.now();
        queue.forEach(function(task){
          if(now - task.executeTime >= 0){
              task.work();
          }
        });

4、实现类似java中的sleep函数
   function sleep(ms){
     var start = Date.now();
     while(Date.now()- start < ms);
   }

5、变量结构赋值
   
   基本语法: http://es6.ruanyifeng.com/#docs/destructuring

   var rs = [[1,2], [3,4]].map(([x, y]) => x + y);
   
   等价于:
   
   1) js伪代码
   function myMap([x, y]){  //这个表明函数接收数组为参数
     return x + y;
   }

   [[1,2], [3,4]].map(myMap);

   2) java伪代码
   List<List> source = new ArrayList();
   List des = new ArrayList();
   for(List e : source){
      Object newVal = map(e);
      des.add(newVal);
   }

   void int map(List arr){
     int x = arr.get(0);
     int y = arr.get(1);
     return x + y;
   }

6、Object.keys(), Object.getOwnPropertyNames(), for in
   1) Object.keys()                  // 只遍历 <自身> 的属性，且属性必须是 <可枚举> 的
      Object.getOwnPropertyNames()   // 只遍历 <自身> 的属性, 包括 <可枚举> 和 <不可枚举>

      例子
      let o = {};
      Object.defineProperty(o, "noEnumerable", {
          value: 1,
          enumerable: false
      })

      Object.defineProperty(o, 'enumerable', {
         value: 2,
         enumerable: true
      })

      let keys_1 = Object.keys(o);
      let keys_2 = Object.getOwnPropertyNames(o);

      console.log(`Object.keys = ${keys_1}`);                 // Object.keys = enumerable

      console.log(`Object.getOwnPropertyNames = ${keys_2}`);  // Object.getOwnPropertyNames = noEnumerable,enumerable
  
  2) for in 可以遍历 <自身> 和其 <父类> 的 <可枚举> 属性
     function Parent(){
     }
     Parent.prototype.tostring = function(){
         console.log("tostring");
     }
     let o = new Parent();
     o.enumerable = 1;
     for(let key in o){
         console.log(key)            //  enumerable, tostring
     }
      
 7 全局变量
   1) 浏览器脚本
      let|var|const a = 1;
      console.log(`window.a = ${window.a}`); // window.a = 1
   2) node 
      REPL(命令行下,直接敲node进入)
        let|var|const a = 1;
        console.log(`global.a = ${global.a}`); // global.a = 1
      脚本中(node index.js)
        let|var|const a = 1;
        console.log(`global.a = ${global.a}`); // global.a = undefined
   这是因为node在执行脚本时,会把脚本包在一个方法中, 所以脚本中的全局变量并不是绑定到global上去的
   
   参考链接: https://stackoverflow.com/questions/34967530/about-global-variables-in-node-js
 
 8 this和arrow function
   let o = {
       name: 'z3',
       p: () => console.log(this)
   }
   o.p();  // node命令行和浏览器中运行结果为 global和 window, node脚本中运行时为空对象{}
   这是因为 arrow function 的this 是继承parent scope的this,
   node命令行的this       global                  // 直接在命令行敲node进入命令行模式
   浏览器中的this         window            
   node脚本中的this       {}                      //  node index.js
   
   参考链接 https://www.codementor.io/@dariogarciamoya/understanding-this-in-javascript-with-arrow-functions-gcpjwfyuc
   
   
