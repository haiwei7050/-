1 泛型基本知识
  class Parent{}
  class Sub1 extend Parent{}
  class Sub2 extend Parent{}

  1) List<Parent> arr = new ArrayList<Parent>();
     arr.put(new Parent());                      // ok

     arr.put(new Sub1());                        // 这两个都ok，是因为List<Parent>规定了  
     arr.put(new Sub2());                        // arr里面只能放 Parent, 而Sub1和Sub2
                                                 // 是一个Parent(有继承关系)

  2) List<Parent> arr = new Array<Sub1>();      //error, 因为泛型没有继承关系

参考链接:https://www.jianshu.com/p/ddbe1db509da
  

2 PECS(Producer extends and Consumer super)
  1) 你有个方法，方法要对泛型集合进行操作
      
     ------------------------- ? extend 只从方法参数的集合中取数据
      void pop(List<? extend Parent> list){     
          Parent a = list.get(0);               //  这步ok
          list.add(a);                          //  这步error，因为 ? extend意味着只能取数据

          Sub1 b =  list.get(0);                //  这步不行，取出的数据的类型必须为extend右边的类型
                                                //  这里为 Parent
      }
      List<Sub1> sub1List = Arrays.asList(new Sub1());

      pop(sub1List);                             

    -------------------------? super 只向方法参数的集合中放数据
     
     void push(List<? supper Sub1> list){     
          list.put(new Sub1());              // 这步ok
          list.put(new Parent());            // 这步不行, 放到集合里的数据的类型必须为extend右边的类型
                                             // 这里是 Sub1
     }

     List<Parent> container = new ArrayList();
     push(container);


3.PECS(Producer extends and Consumer super) 经典案例

	① 从 集合  只取         ------> ? extends E
	② 从 集合  只放         ------> ? super E
	③          又取又放     ------>  先?，后<E>
	https://stackoverflow.com/questions/2723397/what-is-pecs-producer-extends-consumer-super

        ------------------------- ? extend 只从方法参数的集合中取数据
	   
	   Set<Integer> s1 = new HashSet<>(Arrays.asList(1, 2));
	   Set<Double>  s2 = new HashSet<>(Arrays.asList(0.11, 0.22));
	   Set<Number> number = union(s1, s2);

	   <E> Set<E> union(Set<? extends E> s1, Set<? extends E> s2)
          {
              //方法传进两个集合，要把它们的内容收集到一起
              // 所以我们需要： 从方法参数的集合中取数据
              // 所以要用 ? extend

	      Set<E> result = new HashSet<>();
	      for (E e : s1) {
                result.add(e);    
              }
              
              for (E e : s1) {
                result.add(e);
              }
        
	      return result;
	   }

         -------------------------? super 只向方法参数的集合中放数据
          public class Box<E>{
	      private Set<E> thingSet = new HashSet<>();
	      public void popAll(Set<? super E> container){
		 for(E e : thingSet){
		    container.add(e);
		 }
	      }
	      public void put(E e){
		 thingSet.put(e);
	      }
	   }
           
	   Box<Integer> a = new Box<>();
	   a.put(1);
	   a.put(2);
	   Set<Number> result = new HashSet<>();
	   a.popAll(result);


	 ------------------------先?后<E>又放又取
	    先 ?
	    public static void swap(List<?> list, int i, int j){
		   swapInternal(list, i , j);
	    }
	    
	    后<E>
	    private static <E> void swapInternal(List<E> list, int i, int j) {
		list.set(j, list.set(i, list.get(j)));
	    }




2、recursive type parameter（例如 class Builder<T extends Builder<T>>）的作用

   class Builder<T extends Builder<T>>

   A、T 是参数化类型
   B、T 是Builder的子类
   C、T extends Builder<T> ，第二个T必须和前一个T一样

作用
   A、保证自己和自己比较

   public static <E extend Comparable<E>> E min(List<E> src){
       E min = null;
       for(E e : src){
          if(min == null || min.compareTo(e) < 0){
	      min = e;
	  }
       }
   }

   理由: 因为接口 Comparable，不限制自己只能和自己比，所以需要利用 class Builder<T extends Builder<T>>，来进行限制
                                       |
				       |
				       ∨ 下面是  Comparable不限制自己只能和自己比 的例子

    public interface Comparable<T> {
       int compareTo(T o);
    }

    public class User implements Comparable<Integer>{ // 这样实现，就不是自己和自己比较，即 u1.compareTo(u2)过不了编译
       public int compareTo(int u){
           return 0;
       }
    }

    
